<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CNC CAM</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Bootstrap 5 CSS -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.7/css/bootstrap.min.css" rel="stylesheet" />

  <!-- Font Awesome Free -->
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css"
  />

  <style>
    html, body {
      height: 100%;
      margin: 0;
      font-family: system-ui, "Segoe UI", Roboto, Arial, sans-serif;
      background: #fff;
      color: #212529;
    }
    #app {
      display: flex;
      height: 100vh;
      overflow: hidden;
    }
    #ui {
      width: 360px;
      max-width: 40%;
      padding: 1.5rem 1.25rem;
      background: #f8f9fa; /* Bootstrap light gray background */
      overflow-y: auto;
      border-right: 1px solid #dee2e6;
      /* Force scroll if content overflows */
      scrollbar-width: thin;
    }
    #viewer {
      flex: 1;
      position: relative;
      background: #fff;
    }
    /* Make form labels bold and spaced */
    .form-label {
      font-weight: 600;
      margin-bottom: 0.25rem;
      color: #212529;
    }
    .form-text {
      font-size: 0.8rem;
      color: #6c757d;
      margin-top: -0.5rem;
      margin-bottom: 0.75rem;
    }
    /* Customize buttons */
    button {
      width: 100%;
      margin-bottom: 0.75rem;
    }
    textarea#GCodePreview,
    textarea#gcode {
      background: #e9ecef;
      color: #212529;
      font-family: monospace;
      font-size: 0.85rem;
      height: 160px;
      resize: none;
      border: 1px solid #ced4da;
      border-radius: 0.25rem;
    }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.161.0/build/three.module.min.js",
      "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="app">
    <div id="ui" class="d-flex flex-column">

      <div class="mb-3">
        <button id="loadBtn" class="btn btn-dark btn-sm">
          <i class="fas fa-upload me-1"></i> Load 3D File (.stl, .obj, .ply)
        </button>
        <!-- Updated accept attribute -->
        <input id="file" type="file" accept=".stl,.obj,.ply" class="d-none" />
      </div>

      <!-- UI Structure -->
      <div class="mb-2">
        <div class="input-group input-group-sm">
          <span class="input-group-text">Operation</span>
          <select id="operation" class="form-select">
            <option value="roughing">Roughing</option>
            <option value="finishing" selected>Finishing</option>
          </select>
        </div>
      </div>

      <div class="mb-2" id="strategyGroup">
        <div class="input-group input-group-sm">
          <span class="input-group-text">Strategy</span>
          <select id="strategy" class="form-select">
            <option value="waterline" selected>Waterline</option>
            <!-- <option value="raster">Raster</option> -->
          </select>
        </div>
      </div>

      <div class="mb-2">
        <div class="input-group input-group-sm">
          <span class="input-group-text">Endmill Diameter</span>
          <input id="dia" type="number" value="6" step="0.1" class="form-control form-control-sm" />
          <span class="input-group-text">mm</span>
        </div>
      </div>

      <div class="mb-2">
        <div class="input-group input-group-sm">
          <span class="input-group-text">Stepdown</span>
          <input id="stepdown" type="number" value="1" step="0.1" class="form-control form-control-sm" />
          <span class="input-group-text">mm</span>
        </div>
      </div>

      <!-- MODIFIED: Stepover is now a percentage -->
      <div class="mb-2" id="stepoverGroup">
        <div class="input-group input-group-sm">
          <span class="input-group-text">Stepover</span>
          <input id="stepover" type="number" value="40" step="1" min="1" max="100" class="form-control form-control-sm" />
          <span class="input-group-text">%</span>
        </div>
      </div>

      <div class="mb-2" id="stockAllowGroup">
        <div class="input-group input-group-sm">
          <span class="input-group-text">Allowance</span>
          <input id="stockAllow" type="number" value="0.2" step="0.01" class="form-control form-control-sm" />
          <span class="input-group-text">mm</span>
        </div>
      </div>

      <div class="mb-4" id="dirGroup">
        <div class="input-group input-group-sm">
            <span class="input-group-text">Raster Direction</span>
            <select id="dir" class="form-select form-select-sm">
                <option value="x">X (lines along Y)</option>
                <option value="y">Y (lines along X)</option>
            </select>
        </div>
      </div>

      <button id="genPaths" class="btn btn-success btn-sm">
        <i class="fas fa-cogs me-1"></i> Generate Toolpaths
      </button>

      <div class="mb-3">
        <label class="form-label small fw-semibold">Layer Visualization</label>

        <div class="form-check">
          <input class="form-check-input" type="checkbox" value="toolpath" id="showToolpath" checked>
          <label class="form-check-label" for="showToolpath">Toolpath (green)</label>
        </div>
      </div>

      <button id="viewTop" class="btn btn-secondary btn-sm">
        <i class="fas fa-eye me-1"></i> View From Top
      </button>

      <button id="exportGcode" class="btn btn-primary btn-sm">
        <i class="fas fa-file-code me-1"></i> Export GRBL G-code
      </button>

    </div>

    <div id="viewer"></div>
  </div>

<!-- Hidden Modals -->
  <div class="modal fade" id="progressModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="progressTitle">Processing...</h5>
        </div>
        <div class="modal-body">
          <div class="progress">
            <div id="progressBar" class="progress-bar progress-bar-animated"
                 role="progressbar" style="width: 0%, height: 40px;">0%</div>
          </div>
          <p id="progressText" class="mt-2 mb-0 small"></p>
        </div>
      </div>
    </div>
  </div>
  <div class="modal fade" id="errorModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content border-danger">
        <div class="modal-header bg-danger text-white">
          <h5 class="modal-title">Error</h5>
        </div>
        <div class="modal-body" id="errorText"></div>
        <div class="modal-footer">
          <button type="button" class="btn btn-danger" data-bs-dismiss="modal">Close</button>
        </div>
      </div>
    </div>
  </div>
  <div class="position-fixed bottom-0 end-0 p-3" style="z-index: 1055">
    <div id="completionToast" class="toast align-items-center text-bg-success border-0" role="alert" aria-live="assertive" aria-atomic="true">
      <div class="d-flex">
        <div class="toast-body" id="completionText">Completed!</div>
        <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
      </div>
    </div>
  </div>


<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { MOUSE } from 'three';
// Import necessary loaders
import { STLLoader } from 'three/addons/loaders/STLLoader.js';
import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';


// --- 3D Scene Setup (no changes) ---
const container = document.getElementById('viewer');
const renderer = new THREE.WebGLRenderer({antialias:true});
function resizeRenderer() {
  const uiWidth = document.getElementById('ui').offsetWidth;
  renderer.setSize(window.innerWidth - uiWidth, window.innerHeight);
}
resizeRenderer();
renderer.setPixelRatio(window.devicePixelRatio);
container.appendChild(renderer.domElement);
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xffffff);
let frustumSize = 400;
const uiWidth = document.getElementById('ui').offsetWidth;
const aspect = (window.innerWidth - uiWidth) / window.innerHeight;
const camera = new THREE.OrthographicCamera(
  -frustumSize * aspect / 2, frustumSize * aspect / 2,
  frustumSize / 2, -frustumSize / 2,
  0.01, 10000
);
camera.up.set(0,0,1);
camera.position.set(200,200,200);
camera.lookAt(0,0,0);
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.mouseButtons = { LEFT: MOUSE.PAN, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.ROTATE };
controls.screenSpacePanning = true;
const grid = new THREE.GridHelper(400, 40, 0xcccccc, 0xeeeeee);
grid.rotation.x = Math.PI/2;
scene.add(grid);
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(1,2,3);
scene.add(light);
scene.add(new THREE.AmbientLight(0x666666));
let meshGroup = new THREE.Group(); scene.add(meshGroup);
let pathGroup = new THREE.Group(); scene.add(pathGroup);
// --- End 3D Scene Setup ---


// --- UI Element References ---
const fileInput = document.getElementById('file');
const loadBtn = document.getElementById('loadBtn');
const diaInput = document.getElementById('dia');
const stepoverInput = document.getElementById('stepover');
const stepdownInput = document.getElementById('stepdown');
const dirInput = document.getElementById('dir');
const genPathsBtn = document.getElementById('genPaths');
const exportBtn = document.getElementById('exportGcode');
const viewTopBtn = document.getElementById('viewTop');
const stockAllowInput = document.getElementById('stockAllow');

const operationSelect = document.getElementById('operation');
const strategySelect = document.getElementById('strategy');
const strategyGroup = document.getElementById('strategyGroup');
const stepoverGroup = document.getElementById('stepoverGroup');
const dirGroup = document.getElementById('dirGroup');
const stockAllowGroup = document.getElementById('stockAllowGroup');

let loadedMesh = null;
let meshBounds = null;
let lastPaths = [];
let lastMsg = {};

// --- File Loading and Parsing (no changes) ---
loadBtn.addEventListener('click', () => fileInput.click());
fileInput.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) {
        loadFile(file);
    }
});
function loadFile(file) {
    const fileName = file.name.toLowerCase();
    const extension = fileName.substring(fileName.lastIndexOf('.'));
    clearAll();
    const loader = new THREE.FileLoader();
    const isTextFormat = (extension === '.obj');
    loader.setResponseType(isTextFormat ? 'text' : 'arraybuffer');
    loader.load(
        URL.createObjectURL(file),
        (data) => {
            let geometry;
            let mesh;
            try {
                if (extension === '.stl') {
                    const stlLoader = new STLLoader();
                    geometry = stlLoader.parse(data);
                } else if (extension === '.obj') {
                    const objLoader = new OBJLoader();
                    const group = objLoader.parse(data);
                    mesh = group.children.find(child => child.isMesh);
                    if (mesh) {
                        geometry = mesh.geometry;
                    } else {
                        throw new Error("OBJ file contains no mesh geometry.");
                    }
                } else if (extension === '.ply') {
                    const plyLoader = new PLYLoader();
                    geometry = plyLoader.parse(data);
                } else {
                    throw new Error(`Unsupported file type: ${extension}`);
                }
                if (!geometry) {
                    throw new Error("Failed to load geometry from file.");
                }
                if (!mesh) {
                    geometry.computeVertexNormals();
                    mesh = new THREE.Mesh(geometry, createMaterial(geometry));
                } else {
                    geometry.computeVertexNormals();
                    mesh.material = createMaterial(geometry);
                }

                const initialBounds = new THREE.Box3().setFromObject(mesh);
                const modelCenter = initialBounds.getCenter(new THREE.Vector3());
                const xOffset = -modelCenter.x;
                const yOffset = -modelCenter.y;
                const zOffset = -initialBounds.min.z;

                mesh.geometry.translate(xOffset, yOffset, zOffset);
                mesh.geometry.computeBoundingBox();

                meshGroup.add(mesh);
                loadedMesh = mesh;
                meshBounds = mesh.geometry.boundingBox.clone();

                const center = meshBounds.getCenter(new THREE.Vector3());
                const size = meshBounds.getSize(new THREE.Vector3());
                setCameraTopView(center, Math.max(size.x, size.y, size.z));
            } catch (e) {
                showError("Error processing geometry: " + e.message);
            }
        },
        undefined,
        (error) => {
            showError("Error loading file: " + error.message);
        }
    );
}
function createMaterial(geometry) {
    const pos = geometry.attributes.position;
    const faces = pos.count / 3;
    const colors = new Float32Array(pos.count * 3);
    const A = new THREE.Vector3(), B = new THREE.Vector3(), C = new THREE.Vector3(), N = new THREE.Vector3();
    for (let i=0; i<faces; i++) {
        A.fromBufferAttribute(pos, i*3 + 0);
        B.fromBufferAttribute(pos, i*3 + 1);
        C.fromBufferAttribute(pos, i*3 + 2);
        N.copy(new THREE.Vector3().subVectors(C,B).cross(new THREE.Vector3().subVectors(A,B))).normalize();
        const isOverhang = N.z < 0;
        const col = isOverhang ? new THREE.Color(0xdc3545) : new THREE.Color(0x0d6efd);
        for (let v=0; v<3; v++) {
            colors[(i*3+v)*3+0] = col.r;
            colors[(i*3+v)*3+1] = col.g;
            colors[(i*3+v)*3+2] = col.b;
        }
    }
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    return new THREE.MeshStandardMaterial({ vertexColors:true, side: THREE.DoubleSide, metalness: 0.1, roughness:0.7 });
}

// --- UI Logic (no changes) ---
function updateUiVisibility() {
  const operation = operationSelect.value;
  const strategy = strategySelect.value;
  strategyGroup.style.display = 'none';
  stepoverGroup.style.display = 'none';
  stockAllowGroup.style.display = 'none';
  dirGroup.style.display = 'none';
  if (operation === 'roughing') {
    stockAllowGroup.style.display = 'block';
    stepoverGroup.style.display = 'block';
  } else if (operation === 'finishing') {
    strategyGroup.style.display = 'block';
    if (strategy === 'raster') {
      stepoverGroup.style.display = 'block';
      dirGroup.style.display = 'block';
    }
  }
}
operationSelect.addEventListener('change', updateUiVisibility);
strategySelect.addEventListener('change', updateUiVisibility);
updateUiVisibility();

// --- Main App Logic (no changes) ---
window.addEventListener('resize', () => {
  const uiWidth = document.getElementById('ui').offsetWidth;
  const aspect = (window.innerWidth - uiWidth) / window.innerHeight;
  camera.left = -frustumSize * aspect / 2; camera.right = frustumSize * aspect / 2;
  camera.top = frustumSize / 2; camera.bottom = -frustumSize / 2;
  camera.updateProjectionMatrix();
  resizeRenderer();
});
function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
animate();
function setCameraTopView(center, maxSize) {
  const uiWidth = document.getElementById('ui').offsetWidth;
  const aspect = (window.innerWidth - uiWidth) / window.innerHeight;
  const size = Math.max(maxSize, 1) * 1.25;
  frustumSize = size;
  camera.left = -frustumSize * aspect / 2; camera.right = frustumSize * aspect / 2;
  camera.top = frustumSize / 2; camera.bottom = -frustumSize / 2;
  camera.updateProjectionMatrix();
  camera.position.set(center.x, center.y, center.z + maxSize * 2.5);
  camera.up.set(0,0,1);
  camera.lookAt(center);
  controls.target.copy(center);
  controls.update();
}
function clearAll() {
  meshGroup.clear(); pathGroup.clear(); loadedMesh = null;
  lastPaths = []; meshBounds = null;
}

// --- Worker Setup and Communication ---
const waterlineWorker = new Worker('worker.waterline.js');

const gcodeWorker = new Worker('worker.gcode.js');
const heightmapWorker = new Worker('worker.heightmap.js', { type: 'module' });

function handleWorkerMessage(ev, workerName) {
  const msg = ev.data;
  if (msg.cmd === 'progress') {
    if (typeof progressModal !== 'undefined' && !progressModal._isShown) showProgressModal(workerName);
    updateProgress(msg.phase, msg.percent, msg.type, workerName);
  }
  else if (msg.cmd === 'waterlineResult' || msg.cmd === 'roughResult') {
    drawLayers(msg);
    lastMsg = msg;
  }
  else if (msg.cmd === 'gcodeResult') {
    progressBar.style.width = `100%`;
    const blob = new Blob([msg.gcode], {type:'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'toolpaths.gcode'; a.click();
    URL.revokeObjectURL(url);
    setTimeout(() => hideProgressModal(), 500);
    showCompletion('G-code generated!');
  }
  else if (msg.cmd === 'error') {
    hideProgressModal();
    showError(`Worker [${workerName}] error: ${msg.message}`);
  }
}

waterlineWorker.onmessage = (ev) => handleWorkerMessage(ev, 'Waterline');
gcodeWorker.onmessage = (ev) => handleWorkerMessage(ev, 'G-code');
heightmapWorker.onmessage = (ev) => handleWorkerMessage(ev, 'Heightmap');


function sendMeshToWorker() {
    if (!loadedMesh) return null;
    let geometry = loadedMesh.geometry.clone();
    const nonIndexed = geometry.index ? geometry.toNonIndexed() : geometry;
    const posAttr = nonIndexed.attributes.position;
    if (!posAttr) {
        showError("Geometry lacks position data.");
        return null;
    }
    const arr = new Float32Array(posAttr.array);
    const triCount = arr.length / 9;
    const bbox = new THREE.Box3().setFromBufferAttribute(posAttr);

    return { triangles: arr, triCount, bbox };
}

// --- Path Generation and G-code Export ---
// MODIFIED: genPathsBtn listener updated for allowance and percentage stepover
genPathsBtn.addEventListener('click', () => {
  if (!loadedMesh) { alert('Load a 3D model first'); return; }
  pathGroup.clear();

  const operation = operationSelect.value;

  const data = sendMeshToWorker();
  if (!data) return;

  const dia = parseFloat(diaInput.value);
  const stepdown = parseFloat(stepdownInput.value);
  const baseParams = {
      triangles: data.triangles,
      triCount: data.triCount,
      bbox: {
        minX: data.bbox.min.x, maxX: data.bbox.max.x,
        minY: data.bbox.min.y, maxY: data.bbox.max.y,
        minZ: data.bbox.min.z, maxZ: data.bbox.max.z
      },
      dia,
      stepdown
  };

  if (operation === 'roughing') {
    const stockAllow = parseFloat(stockAllowInput.value) || 0;
    const stepoverPercent = parseFloat(stepoverInput.value) || 40; // default 40%
    const stepover = dia * (stepoverPercent / 100.0); // calculate stepover in mm

    waterlineWorker.postMessage({
        ...baseParams,
        cmd: 'waterline',
        mode: 'rough',
        stepover,
        stockAllow // Pass allowance to worker
    }, [baseParams.triangles.buffer]);

  } else if (operation === 'finishing') {
    const strategy = strategySelect.value;
    // NOTE: Raster finishing is not implemented, so only waterline is handled.
    waterlineWorker.postMessage({ ...baseParams, cmd: 'waterline', mode: 'waterline' }, [baseParams.triangles.buffer]);
  }
});

function drawLayers(msg) {
  pathGroup.clear();
  lastPaths = [];
  const layers = msg.layers || [];


  const showToolpath = document.getElementById('showToolpath').checked;

  const SCALE = 10000;
  for (const layer of layers) {
    const z = layer.Z;
    if (showToolpath && layer.Toolpath) {
      for (const path of layer.Toolpath) {
        const pts = [];
        for (let i = 0; i < path.length; i += 3) { pts.push(new THREE.Vector3(path[i], path[i + 1], path[i + 2])); }
        lastPaths.push(pts);
        const geom = new THREE.BufferGeometry().setFromPoints(pts);
        pathGroup.add(new THREE.Line(geom, new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.9 })));
      }
    }
  }
  showCompletion(`Generated ${lastPaths.length} toolpath segments`);
  setTimeout(() => hideProgressModal(), 500);
}

['showToolpath'].forEach(id => {
  document.getElementById(id).addEventListener('change', () => {
    if (lastMsg && lastMsg.layers) drawLayers(lastMsg);
  });
});

exportBtn.addEventListener('click', () => {
  if (!lastPaths || lastPaths.length === 0) {
    alert('No toolpaths have been generated yet.');
    return;
  }
  showProgressModal('G-code');
  const plainPaths = lastPaths.map(path => path.map(p => ({ x: p.x, y: p.y, z: p.z })));

  gcodeWorker.postMessage({
    cmd: 'generate',
    paths: plainPaths,
    options: { feed: 800, plunge: 200, safeZ: 5 }
  });
});

viewTopBtn.addEventListener('click', () => {
  if (!loadedMesh) return;
  const box = new THREE.Box3().setFromObject(loadedMesh);
  const center = box.getCenter(new THREE.Vector3());
  const size = box.getSize(new THREE.Vector3());
  setCameraTopView(center, Math.max(size.x, size.y, size.z));
});


// --- Modals and Toasts (no changes) ---
const progressModal = new bootstrap.Modal(document.getElementById('progressModal'), {backdrop:'static', keyboard:false});
const progressBar = document.getElementById('progressBar');
const progressText = document.getElementById('progressText');
const progressTitle = document.getElementById('progressTitle');
const errorModal = new bootstrap.Modal(document.getElementById('errorModal'));
const errorText = document.getElementById('errorText');
const completionToastEl = document.getElementById('completionToast');
const completionToast = new bootstrap.Toast(completionToastEl, {delay: 4000});
const completionText = document.getElementById('completionText');

function showProgressModal(workerName) {
  progressBar.style.width = '0%'; progressBar.textContent = '';
  progressText.textContent = `${workerName} - Starting...`;
  progressTitle.textContent = `Processing...`;
  progressModal.show();
}

function updateProgress(phase, percent, type, workerName) {
  console.log(phase, percent, type, workerName)
    // --- Simple workers: just 1 phase ---
    if (type === 'gcode') {
        const friendlyName = workerName === 'G-code' ? 'G-code' : 'GPU Heightmap';
        progressBar.style.width = `${percent}%`;
        progressText.textContent = `Generating ${friendlyName}...`;
        progressTitle.textContent = `Generating ${friendlyName}... ${percent}%`;
        return;
    }

    // --- Multi-phase workers ---
    const descriptions = {
        Waterline: {
            1: 'Slicing Model',
            2: 'Generating Collision Masks',
            3: 'Generating Toolpaths'
        }
    };

    const phaseDescriptions = descriptions[workerName] || {};
    const stageTotal = Object.keys(phaseDescriptions).length || 1;

    // Scale percent into overall
    const start = (phase - 1) / stageTotal * 100;
    const end = phase / stageTotal * 100;
    const overallPercent = start + (percent / 100) * (end - start);

    const friendlyName = phaseDescriptions[phase] || `Phase ${phase}`;
    progressBar.style.width = `${overallPercent}%`;
    progressText.textContent = `${friendlyName}...`;
    progressTitle.textContent = `Processing ${workerName}... ${Math.round(overallPercent)}%`;
}


function hideProgressModal() { progressModal.hide(); }
function showError(message) { errorText.textContent = message; errorModal.show(); }
function showCompletion(message) { completionText.textContent = message; completionToast.show(); }

</script>

<!-- Bootstrap 5 JS bundle -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.7/js/bootstrap.bundle.min.js"></script>

</body>
</html>
